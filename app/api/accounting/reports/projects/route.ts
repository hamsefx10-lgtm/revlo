// app/api/accounting/reports/projects/route.ts - Project Reports API
import { NextResponse } from 'next/server';
import prisma from '@/lib/db';
import { getSessionCompanyId } from '../auth';

// GET /api/accounting/reports/projects - Get project financial reports
// NOTE: Si looga fogaado ciladaha 500 ee Prisma, waxaan ka dhignay query-ga mid aad u fudud oo la isku halayn karo.
export async function GET(request: Request) {
  try {
    let companyId: string;
    try {
      companyId = await getSessionCompanyId();
    } catch (err) {
      console.error('Project Reports API auth error:', err);
      return NextResponse.json(
        { message: 'Unauthorized: company not found in session' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');

    // Hadda ma isticmaaleyno filter taariikheed gudaha Prisma si aan looga dhalan cilado,
    // balse weli waan soo celinaynaa startDate / endDate si UI-gu u muujiyo.

    // Get company info
    const company = await prisma.company.findUnique({
      where: { id: companyId },
      select: { name: true, logoUrl: true }
    });

    // Get all projects for the company (no complex nested filters)
    const projects = await prisma.project.findMany({
      where: {
        companyId,
      },
      include: {
        customer: { select: { name: true } },
        expenses: {
          select: {
            id: true,
            amount: true,
            category: true,
            description: true,
            expenseDate: true,
            subCategory: true,
            note: true,
            rentalPeriod: true,
            transportType: true,
            consultancyType: true,
            consultantName: true,
            supplierName: true,
            materials: true,
            employee: {
              select: {
                fullName: true,
              },
            },
          }
        },
        transactions: {
          select: {
            id: true,
            amount: true,
            type: true, // Need to check if this is INCOME, SALE, or advance
            description: true,
            transactionDate: true,
            category: true, // Check category/subcategory if relevant
          }
        },
        payments: {
          select: {
            id: true,
            amount: true,
            paymentDate: true,
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    // Calculate financial data for each project
    const projectReports = projects.map(project => {
      // Total revenue from project value/agreement
      const projectValue = Number(project.agreementAmount || 0);

      // 1. Direct Payments (from `payments` relation - usually Invoice payments)
      const directPayments = project.payments.map(p => ({
        id: p.id,
        amount: Number(p.amount),
        date: p.paymentDate?.toISOString().split('T')[0] || '',
        description: 'Invoice Payment',
        source: 'Payment'
      }));

      // 2. Accounting Transactions that are INCOME/SALE or specifically marked
      // User request: "lacagtii u horaysay ee adcanedka ahayd" (Advance) + "accounting transaction"
      // 2. Accounting Transactions (INCOME + DEBT_REPAID + Advance)
      // Including DEBT_REPAID as per user request to capture all payments
      const relevantTransactions = project.transactions
        .filter(t => t.type === 'INCOME' || t.type === 'DEBT_REPAID' || t.description?.toLowerCase().includes('advance'));

      // 3. Advance Payment (Source of Truth: project.advancePaid)
      const advancePaid = Number(project.advancePaid || 0);

      // REVISED LOGIC to match Frontend exactly:
      // 1. Identify valid transactions (excluding auto-advance to avoid double counting with field)
      const validTransactions = relevantTransactions.filter(t => {
        const trxTime = new Date(t.transactionDate).getTime();
        const projTime = new Date(project.createdAt).getTime();
        const isCloseTime = Math.abs(trxTime - projTime) < 5 * 60 * 1000;
        const desc = (t.description || '').toLowerCase();
        const isAutoGenerated = desc.includes('advance payment for project');
        // We EXCLUDE it if it is the auto-generated one (frontend matches by isIncome + desc + time)
        // But here we just exclude based on description + time to be safe regardless of type
        return !(isAutoGenerated && isCloseTime);
      });

      const transactionPayments = validTransactions.map(t => ({
        id: t.id,
        amount: Number(t.amount),
        date: t.transactionDate?.toISOString().split('T')[0] || '',
        description: t.description || (t.type === 'DEBT_REPAID' ? 'Debt Repayment' : 'Income Transaction'),
        source: t.type === 'DEBT_REPAID' ? 'Debt Repayment' : 'Transaction'
      }));

      // 2. Create Virtual Advance Payment
      const virtualAdvance = advancePaid > 0 ? [{
        id: 'advance-sys-' + project.id,
        amount: advancePaid,
        date: project.createdAt.toISOString().split('T')[0],
        description: 'Advance Payment (Initial)',
        source: 'System Record'
      }] : [];

      // Combine all "payments" (Money In)
      const allPayments = [...directPayments, ...transactionPayments, ...virtualAdvance];

      // Sort by date unique
      const sortedPayments = allPayments.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

      // Total payments sum
      const totalPayments = sortedPayments.reduce((sum, p) => sum + p.amount, 0);

      // Expenses by category
      const materialCosts = project.expenses
        .filter(e => e.category === 'Material')
        .reduce((sum, e) => sum + Number(e.amount), 0);

      const laborCosts = project.expenses
        .filter(e => e.category === 'Labor')
        .reduce((sum, e) => sum + Number(e.amount), 0);

      const transportCosts = project.expenses
        .filter(e => e.category === 'Transport')
        .reduce((sum, e) => sum + Number(e.amount), 0);

      const equipmentCosts = project.expenses
        .filter(e => e.category === 'Equipment')
        .reduce((sum, e) => sum + Number(e.amount), 0);

      const utilitiesCosts = project.expenses
        .filter(e => e.category === 'Utilities')
        .reduce((sum, e) => sum + Number(e.amount), 0);

      const consultancyCosts = project.expenses
        .filter(e => e.category === 'Consultancy')
        .reduce((sum, e) => sum + Number(e.amount), 0);

      // Total expenses
      const totalExpenses = project.expenses.reduce((sum, e) => sum + Number(e.amount || 0), 0);

      // Total Revenue currently is effectively Total Payments for Cash Basis/actual revenue?
      // Or should it include invoice amounts not yet paid?
      // Usually "Revenue" in reports = Money In (Total Payments).
      // If we want Accrual, it would be Invoice Total.
      // Based on context "remaining revenue", it seems Revenue = Collected.
      const revenue = totalPayments;

      // Remaining revenue (Debt)
      // Logic: If Expenses > Project Value, assume Debt is at least (Expenses - Paid).
      // This handles "Cost Plus" or cases where Value is placeholder (0).
      // "Dayn" = Max(Value, Expenses) - Paid.
      const remainingRevenue = Math.max(projectValue, totalExpenses) - totalPayments;

      // Cash Balance (Revenue - Expenses)
      const cashBalance = revenue - totalExpenses;

      // Gross profit
      // REVISED LOGIC: For Active/Ongoing projects, do not recognize positive profit (Unrealized).
      // Only recognize losses (Prudence principle).
      // Completed projects show full profit.
      let grossProfit = cashBalance;
      const isOngoing = ['Active', 'On Hold', 'Nearing Deadline', 'Overdue'].includes(project.status);

      if (isOngoing && grossProfit > 0) {
        grossProfit = 0;
      }

      // Profit margin
      // If we capped grossProfit to 0, margin is 0%.
      const profitMargin = revenue > 0 ? (grossProfit / revenue) * 100 : 0;

      // Completion percentage
      const completionPercentage = projectValue > 0 ? (totalPayments / projectValue) * 100 : 0;

      return {
        id: project.id,
        name: project.name,
        status: project.status,
        customer: project.customer?.name || 'N/A',
        startDate: project.startDate?.toISOString().split('T')[0] || '',
        expectedCompletionDate: project.expectedCompletionDate?.toISOString().split('T')[0] || '',
        actualCompletionDate: project.actualCompletionDate?.toISOString().split('T')[0] || '',
        projectValue,
        totalRevenue: revenue,
        totalPayments,
        remainingRevenue,
        materialCosts,
        laborCosts,
        transportCosts,
        equipmentCosts,
        utilitiesCosts,
        consultancyCosts,
        totalExpenses,
        grossProfit,
        profitMargin,
        completionPercentage,
        expenseCount: project.expenses.length,
        transactionCount: project.transactions.length, // All transactions (expense + income)
        paymentCount: sortedPayments.length,
        expenses: project.expenses.map(e => ({
          id: e.id,
          category: e.category,
          description: e.description,
          amount: Number(e.amount),
          date: e.expenseDate?.toISOString().split('T')[0] || '',
          subCategory: e.subCategory || null,
          note: e.note || null,
          rentalPeriod: e.rentalPeriod || null,
          transportType: e.transportType || null,
          consultancyType: e.consultancyType || null,
          consultantName: e.consultantName || null,
          supplierName: e.supplierName || null,
          employeeName: e.employee?.fullName || null,
          materials: e.materials || null,
        })),
        transactions: project.transactions.map(t => ({
          id: t.id,
          type: t.type,
          description: t.description,
          amount: Number(t.amount),
          date: t.transactionDate?.toISOString().split('T')[0] || '',
        })),
        payments: sortedPayments, // Now includes both direct payments and income transactions
      };
    });

    // Calculate summary statistics
    const totalProjects = projectReports.length;
    const activeProjects = projectReports.filter(p => p.status === 'Active').length;
    const completedProjects = projectReports.filter(p => p.status === 'Completed').length;
    const onHoldProjects = projectReports.filter(p => p.status === 'On Hold').length;

    const totalRevenue = projectReports.reduce((sum, p) => sum + p.totalRevenue, 0);
    const totalExpenses = projectReports.reduce((sum, p) => sum + p.totalExpenses, 0);
    const totalProfit = projectReports.reduce((sum, p) => sum + p.grossProfit, 0);

    const averageProfitMargin = totalRevenue > 0
      ? (totalProfit / totalRevenue) * 100
      : 0;

    const summary = {
      totalProjects,
      activeProjects,
      completedProjects,
      onHoldProjects,
      totalRevenue,
      totalExpenses,
      totalProfit,
      averageProfitMargin,
    };

    return NextResponse.json({
      companyName: company?.name || 'Company',
      companyLogoUrl: company?.logoUrl || null,
      startDate: startDate || null,
      endDate: endDate || null,
      projects: projectReports,
      summary,
    }, { status: 200 });
  } catch (error) {
    console.error('Project Reports API error:', error);
    return NextResponse.json(
      { message: 'Cilad server ayaa dhacday. Fadlan isku day mar kale.' },
      { status: 500 }
    );
  }
}
